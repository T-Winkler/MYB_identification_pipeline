---
title: "MYB identification pipeline"
output: pdf_document
params: 
  myParam1:
    label: "Species name"
    value: "insert_species_name_here"
    input: text
  myParam2:
    label: "Path to gff-file"
    value: "insert_gff_path_here"
    input: text
  myParam3:
    label: "Path to assembly fasta"
    value: "insert_assembly_fasta_here"
    input: text 
  myParam4:
    label: "Path to HMM input fasta"
    value: "insert_path_to_hmm_input_here"  
    input: text
---

The identification pipeline uses a fasta file of putative MYB candidate proteins as main input. The file should include the sequence of all proteins identified by the two complementary approaches BLAST and HMM scan in the proteome of the species. Four parameters have to be manually defined. The species name is the first parameter and is used to generate figure captions and file names. The path to the gff-file of the genome annotation (parameter 2) is used to create the ideogram and a table of identified MYBs with their respective genomic position. The path to the fasta file of the genome assembly (parameter 3) is required to generate the ideogram. Parameter 4 specifies the path to the input fasta file of putative MYB proteins. The files for the parameters 2, 3 and 4 could be saved anywhere, as long as the correct path is given, but can also be saved at Data/parameter_files/.

Parameter 1: Species name/identifier, no file needed
Parameter 2: Path, gff3 file of the genome annotation used
Parameter 3: Path, fasta file of the genome assembly used
Parameter 4: Path, fasta file of proteins identified by BLAST and HMM scan

Required software:
HMMER command line application
  (http://hmmer.org)
CLUSTALW command line apllication
  (http://www.clustal.org/clustal2/)

The pipeline requires a similar folder architecture to the github repository. The working directory has to be set accordingly. The working directory can be defined in the R setup code chunk below.
(change root.dir = '...')

```{r setup, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Users/tomwinkler/Documents/MYB_family/Identification_pipeline/')
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=FALSE)
```


The system environment is set to access parameters as variables from bash code chunks within this document.

```{r, message=FALSE}
Sys.setenv(param1=params$myParam1)
Sys.setenv(param2=params$myParam2)
Sys.setenv(param3=params$myParam3)
Sys.setenv(param4=params$myParam4)
```


## HMMscan analysis
\
\
Installation of the HMMER command line application is required. A fasta file with protein sequences of putative MYB genes is used as input, generated by a full outer join of the proteins found by either the proteome-wide HMM scan and/or the BLAST search. A HMM scan is run on the file with the --domtblout option, the output file is edited to exclude lines with the character "#". The --domtblout generates an output file that returns a table including each identified domain of every protein. This output format allows for filtering of individual domains in multi-domain proteins.
\
```{bash}
hmmscan --domtblout \
Output/HMMscans/${param1}_hmm.txt \
Data/HMM_scan_files/Myb_DNA-binding.hmm.txt \
${param4}

cat Output/HMMscans/${param1}_hmm.txt | \
grep -v "#" > \
Output/HMMscans/${param1}_hmm_edit.txt
```


All libraries necessary for the next steps are loaded, the working directory is set. 
\
```{r, message=FALSE}
library(cowplot)
library(ggrepel)
library(wesanderson)
library(ape)
library(seqinr)
library(tidyverse)
```

The edited output file of the HMMscan is imported into R. A new column "alignment_length" is added, that represents the length of the alignment of protein sequence and HMM profile. For better readability, column names are changed. Filtering is done on the parameters domain score, alignment length and accuracy. 
The following code is used to filter identified domains and to divide the identified MYB proteins into their respective subfamily. 
The code used to classify proteins of A. thaliana and B. vulgaris is identical to the following code used to identify MYB proteins, except that the names of all used variables were adjusted. To avoid repititions, I only annotated the HMM analysis code once. The HMM scan analysis code is repeated for A. thaliana and B. vulgaris with different variable names '_a' and '_b'.
Despite that MYB proteins of A. thaliana and B. vulgaris having been reported before, HMMscans were used to divide the proteins into their respective subfamilies to allow for coloring of the phylogenetic tree. The classification of MYB genes of A. thaliana and B. vulgaris by the identification pipeline is similar to the classification in the literature.   
\


```{r }
# Read hmmscan output file into variable data 
data <- read.table(paste("Output/HMM_scans/",params$myParam1,"_hmm_edit.txt", sep = ""),
                   row.names = NULL, fill = T)
## Add column including the length of alignment
data <- data %>%
  mutate(alignment_length = V17-V16)

## Add Column names back 
colnames(data) <- c('target_name','target_accession','tlen','query_name','accession',
                    'qlen','E-value','score_all','bias_all','nr_domain',
                    'total_domains','c-Evalue','i-Evalue','score_domain',
                    'bias_domain','from_hmm_coord','to_hmm_coord','from_ali_coord',
                    'to_ali_coord','from_env_coord','to_enc_coord','acc',
                    'description','of','target','alignment_length')


# Filter based on domain_score, alignment_length and acc
## Filter for a domain score > 25
data_filtered <- data %>%
  filter(score_domain > 25)
## Filter for an alignment length > 20
data_filtered <- data_filtered %>%
  filter(alignment_length > 20)
## Filter for acc > 0.8
data_filtered_acc <- data_filtered %>%
  filter(acc > 0.8)
### Number of unique proteins after filtering steps
length(unique(data_filtered[['query_name']]))
### Number of domains before and after filtering steps:
nrow(data)
nrow(data_filtered)
```

It is investigated, whether each identified protein contains adjacent or non-adjacent domains. The data has to be already filtered based on score, alignment length and accuracy, otherwise many domains with low similarity to the complete MYB domain are reported. These false positives could interfere with the identification of non-adjacent domains. 
First, the domains are sorted so that each proteins domains follow one another. For each row (=each domain), it is checked whether the column "query_name" is equal to the next row (=whether the next domain belongs to the same protein). If the query names of both domains are unequal, a 0 is assigned to a vector (there is no use in comparing domains of different proteins). If the query names are equal, it is checked whether the end of the current and the start of the next domain are less than 15 residues apart from each other. If they are closer to the each other than 15 amino acids, they are considered adjacent and a 0 is added to the vector. If they are further apart from each other, they are considered non-adjacent and a 1 is added to the vector. In the end, a 0 is added to the vector, as the last row can not be compared to the next row. As the last row represents the last domain of a certain protein, it has already been checked whether it is adjacent to the domain before. Therefore, a 0 is added for the last row (domain). 
The vector is added to the data. For each protein, it is checked whether the protein includes non-adjacent domains (checksum of uneqal to 0). If a protein has only adjacent domains, it is included in the filtered data. If it has non-adjacent domains it gets excluded for now and only later added back. 
\
```{r, message=FALSE}
## Filter for adjacent domains
### Make sure that the data is sorted by query_name
data_adjacent <- arrange(data_filtered_acc,query_name)
### Create the variable n and assign it the number of rows of the dataframe
n <- nrow(data_adjacent)
### Create an empty vector
vec <- c()
### For each row from row 1 to row n-1, check if the query_name column of the 
### next row is equal to the query_name column of this row.
### If this is FALSE (protein with just 1 reported domain or last domain 
### in a multi domain protein), assign '0' to the vector.
### If this is TRUE, check whether the start position of the next domain and 
### the end position of the current one are a maximum of 14 AA apart.
### If they are adjacent, assign '0' to the vector, 
### if they are non-adjacent, assign '1' to the vector
### This way a checksum can be created for each domain, if the checksum 
### is unequal to 0, a domain is considered non-adjacent to the next domain
### of the same protein
for(i in seq(1,n-1)) {
  if(data_adjacent[i,4] == data_adjacent[i+1,4]) {
    if(data_adjacent[i+1,18] - data_adjacent[i,19] < 15) {
      vec <- c(vec,'0')
    } else {
      vec <- c(vec,'1')
    }
  } else {
    vec <- c(vec,'0')
  }
}
### Add one additional '0' as the last value, as the last domain can
### not be compared to the next domain (as there is no next row).
vec <- c(vec,'0')
### Add the created vector as a column to the dataframe
vec <- as.numeric(vec)
data_adjacent$adjacent <- vec  
### Group by query_name, sum the checksum and include all proteins
### with checksum=0 in the filtered data.
### Proteins with checksum!=0 are rejoined later
data_checksum <- data_adjacent %>%
  group_by(query_name) %>%
  summarize(.,checksum = sum(adjacent)) %>%
  as.data.frame.data.frame() %>%
  right_join(data_adjacent)
data_filtered <- data_checksum %>%
  filter(checksum == 0)
```

The number of unfiltered and filtered domains is counted for each protein and included in a table. Proteins with non-adjacent domains are considered to be R-R-type and are added to the the dataframe with the filtered data. For R-R-type proteins Freq (=number of domains) is set to 1, as they are part of the MYB-related subfamily. The domains_per_protein dataframe indicates the subfamily of each protein with the number 1-4, the grouped_domains_per_protein table shows the number of proteins per subfamily.
\
```{r }   
# Analyse results
## Group the number of domains for each unique accession and count them
domains_per_protein <- data_filtered %>%
  select(query_name) %>%
  table(dnn = 'query_name')
domains_per_protein <- as.data.frame(domains_per_protein)
### Remove proteins for which all domains were filtered out
domains_per_protein <- domains_per_protein %>%
  filter(Freq > 0)
## Add back the filtered out R-R-type MYB-like proteins
### Select the query_name of domains with checksum unequal to 0,
### and add them to a vector
query_name <- data_checksum %>%
  filter(checksum != 0) %>%
  select(query_name)
### The same query_name could appear multiple times, only keep one of each
query_name <- unique(query_name)
### Create a vector named Freq with set Freq=1, convert unique query names 
### and frequency to a dataframe
Freq <- c(rep(1,nrow(query_name)))
R_R_type <- data.frame(query_name, Freq)
### Combine the dataframe of filtered proteins with the dataframe of  
### R-R-type MYB-like proteins 
domains_per_protein <- rbind(domains_per_protein, R_R_type)
### Group the proteins by their number of domains
### Count the entries of each group
### Create a table with the number of genes per subfamily
grouped_domains_per_protein <- domains_per_protein %>%
  group_by(Freq) %>%
  summarize(count = n())
grouped_domains_per_protein
```

The MYB idenification pipeline is repeated using two provided HMM scans of A. thaliana and B. vulgaris. The MYB proteins of the two plants have been reported in literature and are used as comparison for the identified MYB proteins. The appear in the stacked barplot displaying the number of identified MYB genes and are used as additional input for the phylogenetic tree. As it is unnecesary to always repeat the HMMscan for A. thaliana and B. vulgaris, the HMM scan files for them are already stored under Output/HMM_scans.

```{r, message=FALSE}
# Identified A. thaliana MYB proteins
data_a <- read.table('Output/HMM_scans/AT_myb/AT_myb_edit.txt', row.names = NULL, fill = T)
data_a <- data_a %>%
  mutate(alignment_length = V17-V16)
colnames(data_a) <- c('target_name','target_accession','tlen','query_name','accession','qlen','E-value','score_all',
                    'bias_all','nr_domain','total_domains','c-Evalue',
                    'i-Evalue','score_domain','bias_domain','from_hmm_coord','to_hmm_coord','from_ali_coord','to_ali_coord','from_env_coord',
                    'to_enc_coord','acc','description','of','target','alignment_length')
data_a <- mutate(data_a, query_name = substr(data_a$query_name, 1, 11))

## Filter based on domain_score, alignment_length and acc
data_score_a <- data_a %>%
  filter(score_domain > 25)
data_score_length_a <- data_score_a %>%
  filter(alignment_length > 20)
data_filtered_acc_a <- data_score_length_a %>%
  filter(acc > 0.8)
## Filter for adjacent domains
data_adjacent_a <- arrange(data_filtered_acc_a,query_name)
n <- nrow(data_adjacent_a)
vec <- c()
for(i in seq(1,n-1)) {
  if(data_adjacent_a[i,4] == data_adjacent_a[i+1,4]) {
    if(data_adjacent_a[i+1,18] - data_adjacent_a[i,19] < 15) {
      vec <- c(vec,'0')
    } else {
      vec <- c(vec,'1')
    }
  } else {
    vec <- c(vec,'0')
  }
}
vec <- c(vec,'0')
vec <- as.numeric(vec)
data_adjacent_a$adjacent <- vec  
data_checksum_a <- data_adjacent_a %>%
  group_by(query_name) %>%
  summarize(.,checksum = sum(adjacent)) %>%
  as.data.frame.data.frame() %>%
  right_join(data_adjacent_a)
data_filtered_a <- data_checksum_a %>%
  filter(checksum == 0)
## Filter out results that have the same start positions
## (Despite the different splicing variants, one entry per gene)
data_same_start <- data_filtered_a
n <- nrow(data_same_start)
vec <- c()
for(i in seq(1,n-1)) {
  if(data_same_start[i,1] == data_same_start[i+1,1]) {
    if(data_same_start[i+1,19] == data_same_start[i,19]) {
      vec <- c(vec,'1')
    } else {
      vec <- c(vec,'0')
    }
  } else {
    vec <- c(vec,'0')
  }
}
vec <- c(vec,'0')
vec <- as.numeric(vec)
data_same_start$same_start <- vec  
data_same_start_1 <- data_same_start %>%
  group_by(query_name) %>%
  summarize(.,checksum2 = sum(same_start)) %>%
  as.data.frame.data.frame() %>%
  right_join(data_same_start)
data_filtered_a <- data_same_start_1 %>%
  filter(checksum2 == 0)
## Group the unfiltered domains for each unique accession and count them
domains_per_protein_a <- data_filtered_a %>%
  select(query_name) %>%
  table(dnn = 'query_name')
domains_per_protein_a <- as.data.frame(domains_per_protein_a)
domains_per_protein_a <- domains_per_protein_a %>%
  filter(Freq > 0)
grouped_domains_per_protein_a <- domains_per_protein_a %>%
  group_by(Freq) %>%
  summarize(count = n())
## Add back the R-R-type MYB-like proteins
query_name <- data_checksum_a %>%
  filter(checksum != 0) %>%
  select(query_name)
query_name <- unique(query_name)
### Manually create a vector named Freq with set Freq of 1, convert unique query names and frequency to a dataframe
Freq <- c(rep(1,nrow(query_name)))
R_R_type_a <- data.frame(query_name, Freq)
### Combine the filtered dataframe and the manually set R-R-type MYB-like proteins 
domains_per_protein_a <- rbind(domains_per_protein_a, R_R_type_a)
grouped_domains_per_protein_a <- domains_per_protein_a %>%
  group_by(Freq) %>%
  summarize(count = n())

# Identified B. vulgaris MYB proteins
# Also create variables for the results of the hmmscan of Beta vulgaris
data_b <- read.table('Output/HMM_scans/BV_myb/BV_myb_edit.txt', row.names = NULL, fill = T)
data_b <- data_b %>%
  mutate(alignment_length = V17-V16)
colnames(data_b) <- c('target_name','target_accession','tlen','query_name','accession','qlen','E-value','score_all',
                      'bias_all','nr_domain','total_domains','c-Evalue',
                      'i-Evalue','score_domain','bias_domain','from_hmm_coord','to_hmm_coord','from_ali_coord','to_ali_coord','from_env_coord',
                      'to_enc_coord','acc','description','of','target','alignment_length')
# Filter based on domain_score, alignment_length and acc
data_filtered_b <- data_b %>%
  filter(score_domain > 25)
data_filtered_b <- data_filtered_b %>%
  filter(alignment_length > 20)
data_filtered_acc_b <- data_filtered_b %>%
  filter(acc > 0.8)

data_adjacent_b <- arrange(data_filtered_acc_b,query_name)
n <- nrow(data_adjacent_b)
vec <- c()
for(i in seq(1,n-1)) {
  if(data_adjacent_b[i,4] == data_adjacent_b[i+1,4]) {
    if(data_adjacent_b[i+1,18] - data_adjacent_b[i,19] < 15) {
      vec <- c(vec,'0')
    } else {
      vec <- c(vec,'1')
    }
  } else {
    vec <- c(vec,'0')
  }
}
vec <- c(vec,'0')
vec <- as.numeric(vec)
data_adjacent_b$adjacent <- vec  
data_checksum_b <- data_adjacent_b %>%
  group_by(query_name) %>%
  summarize(.,checksum = sum(adjacent)) %>%
  as.data.frame.data.frame() %>%
  right_join(data_adjacent_b)
data_filtered_b <- data_checksum_b %>%
  filter(checksum == 0)
## Group the unfiltered domains for each unique accession and count them
domains_per_protein_b <- data_filtered_b %>%
  select(query_name) %>%
  table(dnn = 'query_name')
domains_per_protein_b <- as.data.frame(domains_per_protein_b)
domains_per_protein_b <- domains_per_protein_b %>%
  filter(Freq > 0)
grouped_domains_per_protein_b <- domains_per_protein_b %>%
  group_by(Freq) %>%
  summarize(count = n())
## Add back the filtered out R-R-type MYB-like proteins
### Select the query_name of domains with checksum unequal to 0, only keep unique query_names
query_name <- data_checksum_b %>%
  filter(checksum != 0) %>%
  select(query_name)
query_name <- unique(query_name)
### Manually create a vector named Freq with set Freq of 1, convert unique query names and frequency to a dataframe
Freq <- c(rep(1,nrow(query_name)))
R_R_type_b <- data.frame(query_name, Freq)
### Combine the filtered dataframe and the manually set R-R-type MYB-like proteins 
domains_per_protein_b <- rbind(domains_per_protein_b, R_R_type_b)
grouped_domains_per_protein_b <- domains_per_protein_b %>%
  group_by(Freq) %>%
  summarize(count = n())
grouped_domains_per_protein_b
```


### Comparison with gff-file

To find the position of each detected protein in the genome, the gff3-file from the respective genome annotaion is imported into R. A left join of the filtered data and the imported gff3-file is done to obtain the genomic position of each gene. This method only works, if only one primary splicing variant is reported in the genome annotation. To investigate if there are two or more proteins mapping to the same genomic position, the number of unique start and end positions is checked and matched with the number of proteins in the filtered dataset.
\
```{r }
# Comparison with gff file
## Read in gff file of the respective genome
gff <- read.gff(
  paste(params$myParam2)
  )
## Rows are filtered based on type = 'mRNA', to keep only one entry for each gene
### There is only the primary transcript, no splicing variants of genes in the genomes
### of amaranth and quinoa
gff <- gff %>%
  filter(type == 'mRNA')
### Create a new column named 'query_name' that contains the same information as the 
### column in the data_filtered table to ease joining of the tables
gff <- gff %>%
  mutate(query_name = substr(gff$attributes, 4, 14))
data_filtered_gff <- left_join(data_filtered, gff)
## Check the unique position of each protein
### The following code counts the unique strings in the column 'query_name' and the 
### unique values in the 'start' column. This number should be equal, if every protein 
### also has a unique starting position in the genome. As by coincidence two genes
### could have the same starting position on different chromosomes, also the number of
### unique end positions is checked.
query_names_data_filtered_gff <- length(unique(data_filtered_gff[['query_name']]))
start_data_filtered_gff <- length(unique(data_filtered_gff[['start']]))
end_data_filtered_gff <- length(unique(data_filtered_gff[['end']]))
## Print results
if(query_names_data_filtered_gff == start_data_filtered_gff){
  print('Every protein has a unique position in the genome')
} else if (query_names_data_filtered_gff == end_data_filtered_gff){
  print('Every protein has a unique position in the genome')
} else {
  print('Multiple proteins with the same position in the genome have been found')
}
```

## Output

### MYB table

A Table of all identified MYBs is exported. First, the dataframe specifying the subfamily of each protein is left joined with the imported gff dataframe to get the genomic position of every gene. The numbers in the "Freq" column are matched to the respective subfamily. Only necessary columns are kept and some of the columns are renamed. The table is sorted by both scaffold and starting position the respective scaffold. The same steps are repeated for both amaranth and quinoa. The table is saved in the .csv format.
\
```{r }
# Output
## table of all identified MYB genes
### Create a table with the MYB, subgroup and the genomic position
myb_gff <- left_join(domains_per_protein, gff)
### Convert Freq column to subfamily
myb_subfamily <- data.frame(Freq = c(1:4), 
                            subfamily = c('MYB-related', 'R2R3', '3R', '4R'))
myb_gff <- left_join(myb_gff, myb_subfamily)
### Keep only necessary columns, rename columns 
export_table <- myb_gff %>%
  select(query_name,subfamily,seqid,start,end,strand)
export_table <- export_table %>%
  mutate(seqid=substr(export_table$seqid,10,11))
export_table <- export_table %>%
  dplyr::rename(
    gene_name = query_name,
    scaffold = seqid
  )
### Sort dataframe by chromosome and starting position
export_table <- arrange(export_table, as.numeric(scaffold), start)
### Export the table
write.csv(export_table, file = paste("Output/MYB_table/",params$myParam1,".csv", sep=""), quote=F)
```

### Stacked Barplot

A stacked barplot of the number of identified MYB genes of each subfamily is created. To the dataframe showing the number of MYB genes per subfamily, an additional column indicating the species is added. For A. thaliana and B. vulgaris, MYB gene subfamily numbers from the literature are used . The dataframes of all species are joined together and a new column is added to specify the position of the labels. Additionally, a new column "order" was added to the dataframe, which specifies the order of appearance in the barplot. The dataframe "barplot_order" can be adjusted to define a certain sequence of appearance. The barplot is created with ggplot2 and saved as pdf-file.

Number of MYB genes per subfamily in A. thaliana and B. vulgaris:
(Dubos, C., Stracke, R., Grotewold, E., Weisshaar, B., Martin, C., & Lepiniec, L. (2010). MYB transcription factors in Arabidopsis. Trends in plant science, 15(10), 573-581.)
(Stracke, R., Holtgräwe, D., Schneider, J., Pucker, B., Sörensen, T. R., & Weisshaar, B. (2014). Genome-wide identification and characterisation of R2R3-MYB genes in sugar beet (Beta vulgaris). BMC plant biology, 14(1), 249.)
\
```{r }
# Stacked Barplot
## Prepare data
### Add column containing the species to the table that contains the number
### of genes per subfamily
grouped_domains_per_protein <- grouped_domains_per_protein %>%
  mutate(species = paste(params$myParam1))
### Create a dataframe of the number of A. thaliana genes per subfamily
Freq <- c(1,2,3,4)
count <- c(64,126,5,1)
species <- c('A. thaliana','A. thaliana','A. thaliana','A. thaliana')
grouped_domains_per_protein_a_plot <- data.frame(Freq,count,species)
### Create a dataframe of the number of B. vulgaris genes per subfamily
Freq <- c(2,3,4)
count <- c(71,3,1)
species <- c('B. vulgaris','B. vulgaris','B. vulgaris')
grouped_domains_per_protein_b_plot <- data.frame(Freq,count,species)
### Bind all tables together to create a dataframe with all information
joined_grouped_domains <- rbind(
  grouped_domains_per_protein_a_plot,
  grouped_domains_per_protein,
  grouped_domains_per_protein_b_plot
)

### Add a column specifying the position of the labels
### Divide it by 1.2 to make the labels appear at the right subfamily
joined_grouped_domains <- joined_grouped_domains %>%
  group_by(species) %>%
  arrange(desc(Freq)) %>%
  mutate(position = cumsum(count)/1.2) 
### Add a new column to specify the order of the appearance in the barplot
barplot_order <- data.frame(species=c('B. vulgaris','A. thaliana', paste(params$myParam1)),
                            order=c(3,2,1)) 
joined_grouped_domains <- left_join(joined_grouped_domains,barplot_order)
## Plot 
### Use the data to plot the stacked barplot, color each stack by subfamily
barplot <- ggplot() + 
  geom_bar(data=joined_grouped_domains, 
           aes(y=count, x=reorder(species, order), 
               fill=factor(Freq)),
           position='stack', 
           stat='identity', 
           width = 0.6) +
  scale_fill_manual(values=wes_palette("Darjeeling1"), 
                    name='MYB Transcription \nFactor Subfamily',
                    labels= c('MYB-related','R2R3','3R','4R')) +
  geom_text_repel(data=joined_grouped_domains, 
                  aes(x = species, y=position, label=count), 
                  size = 8, 
                  nudge_x = 0.45) +
  ylab('Number of Genes') +
  xlab('Species') +
  ggtitle('Number of MYB Genes per Species') +
  theme_cowplot() +
  theme(plot.title = element_text(size=30, hjust=0.5, face='bold'),
        axis.title.x = element_text(size=25, face='bold'),
        axis.text.x = element_text(size=20),
        axis.title.y = element_text(size=25, face='bold'),
        axis.text.y = element_text(size=20),
        legend.title=element_text(size=20, face='bold'),
        legend.text=element_text(size=15),
        legend.position = "bottom") 

barplot
## Save the plot
ggsave(filename = paste("Plots/",params$myParam1,"_barplot.pdf", sep=""))
```

### Fasta Export

The identified MYB proteins are exported in the fasta format. A fasta file is created (combined.fa) that contains the fasta protein sequences of the defined species, A. thaliana and B. vulgaris. The fasta file is later subset using the list of filtered MYB proteins.


```{bash}
cat ${param4} \
Data/fasta_sequences/AT_myb.fa \
Data/fasta_sequences/BV_myb.fa \
> Data/fasta_sequences/combined.fa
```

First, all dataframes containing the proteins and their classification are combined into one. A vector of all identified MYB sequence names is generated. The combined.fa file is imported. Using the vector of identified MYB protein names the combined.fa fasta file is subset. A new fasta file, containing only the sequences of the identified proteins is exported (putative_myb.fa).

\
```{r}
## Export filtered proteins
### To do the MSA, a fasta-file containing the sequences of only the filtered 
### protein sequences has to be created.
### For subsetting, a vector containing all filtered protein names is created
### Create a dataframe of all filtered proteins
domains_all <- rbind(domains_per_protein,
                     domains_per_protein_a,
                     domains_per_protein_b)
### Create a vector of the query_names (= gene name) column 
putative_mybs <- domains_all %>%
  select(query_name)
### Read in a file containing all A. thaliana and B. vulgaris MYBs,
### in addition to all putative MYBs
### (= Fasta used as input for the HMMscan)
fasta_file <- seqinr::read.fasta(file = 
            "Data/fasta_sequences/combined.fa", 
            seqtype = "AA",
            as.string = TRUE, 
            set.attributes = FALSE)
### Subset it using the gene name list 
fasta_file_subset <- fasta_file[names(fasta_file) %in% putative_mybs$query_name]
### Export a fasta file of all identified MYB genes in the species,
### in addition to all A. thaliana and B. vulgaris MYBs.
write.fasta(sequences = fasta_file_subset, 
            names = names(fasta_file_subset), 
            nbchar = 80, 
            file.out = "Output/myb_fasta/putative_myb.fa")
```

## Genomic position of MYB genes

### Data preparation 

All necessary additional packages are loaded.
\
```{r, message=FALSE}
library(GenomicRanges)
library(ggbio)
```

The table that contains all identified MYB proteins and their respective subgroups are joined with the gff dataframe to obtain the genomic position of each gene. The "seqid" column is edited to only contain the pseudochromosome number, instead of "scaffold_number" to ease sorting by chromosome. A dataframe "point_size" is constructed, that is used to define the size of points in the plot for different subfamilies. Proteins located not on chromosome scaffolds but on contigs are filtered out. Both dataframes are joined and converted into a GenomicRanges object. The approach relies on the phytozome naming convention (scaffold_X) to extract the chromosome number and to sort the chromosomes. For different naming conventions the code has to be adjusted.
\
```{r, message=FALSE}
## GRanges object of identified MYB genes
### Create a table with the MYB, subgroup and the genomic position
myb_gff <- left_join(domains_per_protein, gff)
### Rename Scaffold_X to X, sort based on X
genomic_positions <- myb_gff %>%
  mutate(seqid = substr(myb_gff$seqid,10,11))
genomic_positions$seqid <- as.numeric(as.character(genomic_positions$seqid))
genomic_positions <- genomic_positions %>%
  arrange(seqid)
  
### Construct a dataframe used to define pointsize for each subgroup
point_size <- data.frame(
  Freq = c(1,2,3,4),
  radius = c(1,2,2,2)
)
genomic_positions <- left_join(genomic_positions, point_size)
### Filter entries which are located on contigs
genomic_positions <- genomic_positions[!is.na(genomic_positions$seqid),]
  
### Convert the data.frame to an GRanges object 
granges_species <- makeGRangesFromDataFrame(genomic_positions,
                                       keep.extra.columns = TRUE)
```

To extract the chromosome sizes, the following bash code is run. A text file is created that specifies the scaffold and the respective size based on the assembly fasta file. The text file is later be imported into R.

\
```{bash}
awk '/^>/{if (l!="") print l; print; l=0; next}{l+=length($0)}END{print l}' \
${param3} |paste - - > \
Output/scaffold_sizes/scaffold_size.txt
```

The imported text file is filtered to only keep scaffolds that contain a MYB gene. A dataframe is created that includes the chromosome (scaffold) names, their start and end (their size) and the strand indication necessary to generate the GRanges object. Similar to the MYB dataframe (genomic_positions), the scaffold names are sorted and edited to only include the chromosome number. A GRanges object is constructed from the dataframe. 

```{r, message=FALSE}
## GRanges object of chromosomes
chromosomes <- read.table(file = "Output/scaffold_sizes/scaffold_size.txt")
### Subset the data frame, keep only scaffolds with a MYB gene
chromosomes <- chromosomes %>%
  mutate(scaffold = sub('.','', chromosomes$V1)) %>%
  select(scaffold, V3)

### Bring scaffold data into the right format
chr_subset <- subset(chromosomes, scaffold %in% myb_gff$seqid)
chr_subset <- chr_subset %>% 
  mutate(scaffold = substr(chr_subset$scaffold, 10, 11)) 
### Remove rows with 'NA', sort by chromosome
chr_subset$scaffold <- as.numeric(chr_subset$scaffold)
chr_subset <- na.omit(chr_subset)
chr_subset <- arrange(chr_subset, scaffold)
### Rename columns to seqnames and end
chromosome_ranges <- chr_subset %>%
  dplyr::rename(seqnames = scaffold, 
                end = V3) 
### Create columns start and strand
chromosome_ranges <- chromosome_ranges %>%
  mutate(start = 1) %>%
  mutate(strand = '*')
### Create the GRanges object
chromosome_granges <- makeGRangesFromDataFrame(chromosome_ranges)
```

Sequence lengths and sequence levels are set for both GRanges objects. Because the chromosomes are named from 1 to 16, the sequence levels could be set using a vector of 1 to the number of chromosomes. As sequence lengths values, a vector of end positions of the all chromosomes is used. It is important, that sequence lengths and sequence levels are identical for both objects, as they define the scale of the ideogram plot.

```{r}
### Add seqlengths and seqlevels to the GRanges objects
### seqlevels is a vector of 1 to the number of scaffolds due to the renamed scaffolds
### seqlengths is a vector of the end position of each chromosome (= the total length)
seqlengths(chromosome_granges) <- c(chromosome_ranges$end)
seqlevels(chromosome_granges) <- c(as.character(1:nrow(chromosome_ranges)))
seqlengths(granges_species) <- c(chromosome_ranges$end)
seqlevels(granges_species) <- c(as.character(1:nrow(chromosome_ranges)))
```

### Ideogram Plot

The ggbio function is used to create the ideogram. On the outside, the species chromsomes are plotted, in the innermost layer the different MYB genes are plotted to their genomic position. The MYB genes are represented as points and colored based on their respective subfamily. The MYB gene subfamilies are divided into different tracks along the vertical axis based on their respective subfamily to increase readability. 
\
```{r }
## Plot the ideogram
### Use the ggbio function, edit the plot using ggplot2 functions
p1 <- ggbio::ggbio() +
  ggbio::circle(granges_species, 
                geom = 'point', 
                aes(y = Freq, color = factor(Freq), size=factor(radius)), 
                alpha = 0.6, 
                trackWidth = 12,               
                radius = 46) +
  ggbio::circle(chromosome_granges, 
                geom = "ideo", 
                fill = 'lightsteelblue4', 
                trackWidth = 10,
                radius= 60) +
  ggbio::circle(chromosome_granges, 
                geom = 'scale', 
                size = 2,
                radius = 70) +
  ggbio::circle(chromosome_granges, 
                geom = 'text', 
                aes(label=seqnames), 
                size = 4, 
                vjust = - 0.2) +
  scale_color_manual(values=wes_palette("Darjeeling1"), 
                     name='MYB transcription \nfactor subfamily',
                     labels= c('MYB-related','R2R3','3R','4R')) +
  scale_size_discrete(range=c(1,2), 
                      guide=FALSE) +
  ggtitle(paste("Ideogram of identified",params$myParam1,"MYB genes", sep=" ")) +
  guides(color = guide_legend(override.aes = list(size=4))) +
  theme(legend.title=element_text(size=17, face='bold'),
        legend.text=element_text(size=12),
        plot.title = element_text(size=22, hjust=0, face='bold'))
p1
ggsave(filename = paste("Plots/",params$myParam1,"_myb_ideogram.png", sep = ""))
```


## Multiple sequence alignment

Multiple sequence alignment is done with the ClustalW application. The exported fasta file of all filtered MYB genes is used as input for the alignment. The sequences are aligned with ClustalW using the default setting. 
\
```{bash }
clustalw2 -align \ 
-infile=Output/myb_fasta/putative_myb.fa \ 
-outfile=Output/CLUSTALW/combined_filtered.aln
```



## Phylogenetic tree construction

The neighbour joining tree is constructed and bootstrapped with 1,000 replicates using the CLUSTALW apllication. As input of the application, the alignments created with ClustalW are used.
\
```{bash, eval=FALSE}
clustalw2 -bootstrap=1000 \
-infile=Output/CLUSTALW/combined_filtered.aln \ 
-outfile=Output/CLUSTALW/combined_filtered.phb
```

To visualise the tree, the .phb file is imported into R. The additional packages necessary for the visualisation are loaded. 
\
```{r, message=FALSE}
library(poppr)
library(ggtree)
```

For coloring of the tree, a column indicating the species is added to the dataframe defining the subgroups of all identified MYB proteins. The color palette used for coloring of the tree is defined. The .phb file is imported into R to create the ggtree object. The edited dataframe of all MYB proteins is added to the ggtree object to enable coloring. The tip labels are colored based on species, tippoints are added and colored based on subfamily classification. Bootstrap values in percentage are shown as nodelabels. Bootstrap values of 0% are excluded from the tree. The phylogenetic tree is saved as pdf file.

\
```{r, eval=FALSE}
# Phylogenetic tree creation
### The accessions data.frame will be added to the ggtree object as data
### It allows for coloring based on the species and the subgroup a protein
### has been classified into.
accessions <- domains_all %>%
  mutate(species = substr(domains_all$query_name, 1, 2))
accessions <- accessions %>%
  mutate(name = substr(accessions$query_name, 1, 30))


## Phylogenetic tree, created with CLUSTALW
### Color palette used for coloring of the tree
### Four colors from the wesanderson package with four additional colors
pal2 <- c("#FF0000", "#00A08A", "#F2AD00", "#F98400",
          "#D55E00", "#E69F00", "#56B4E9", "#0072B2")
### Read in the .phb file
tree <- read.raxml('Output/CLUSTALW/combined_filtered.phb')
### Create the ggtree object
t <- ggtree(tree, branch.length = 'none', layout='circular', size=0.2) 
### Add the accessions dataframe as addintional data to allow for coloring
### Color the label based on species, add a tippoint colored based on subfamily
t_species <- t %<+% accessions + 
  ggtitle(paste("Phylogenetic tree of A. thaliana, B. vulgaris and",params$myParam1,"MYB proteins", sep=" ")) +
  geom_tippoint(size=0.02, 
                aes(color = factor(Freq))) +
  geom_tiplab(size=0.5, 
              aes(angle = angle, color = species), 
              hjust= -0.06) +
  geom_text2(size=0.5, 
             nudge_x = 0.5,
             aes(subset=!isTip&(bootstrap>10), 
                 label=floor(bootstrap/10), 
                 angle=angle)) +
  scale_shape_discrete(solid=F) +
  scale_color_manual(values = c(pal2),
                     labels = c('Amaranth','A. thaliana','Quinoa','B. vulgaris'), 
                     name = 'Species') +
  theme(legend.position = 'none',
        legend.direction = 'vertical',
        plot.title = element_text(size=25, face='bold'), 
        legend.title = element_text(size = 20, face='bold'),
        legend.text = element_text(size = 14),
        legend.key.size = unit(1,'cm')) +
  guides(color = guide_legend(override.aes = list(size = 10)))
t_species
ggsave(filename = paste("Plots/",params$myParam1,"_phylogeny.pdf", sep = ""))
```





# Additional Code (DO NOT RUN)

## Subgroup annotation

Subgroups were annotated on the phylogenetic tree. Each subfamily had to be manually defined and added to the tree. The process cannot be automised. The geom_strip() function allows to create a label between two defined taxa. For the classification of subgroups, see the materials and methods part. The angle of the text had to be manually defined for each subgroup. If only a single protein was assigned to a subgroup, the label could be created using the adjacent protein labels (example below)
\
```{r, eval=FALSE}
t_species + 
  geom_strip(nodeid(tree,'AUR62027278-RA'),
             nodeid(tree,'AT5G14340.1'), 
             barsize=0.3,
             offset = 5, 
             fontsize=1.5, 
             extend=0.2, 
             label ='SX') +
  ## Incase only a single protein forms a subgroup:
  ## To annotate a clade for a hypotetical protein X, located between AT1G06180.1 and Bv5ug126530_qcwx
  geom_strip(nodeid(tree,'AT1G06180.1'),
             nodeid(tree,'Bv5ug126530_qcwx'), 
             barsize=0.3, 
             offset = 5, 
             fontsize=1.5, 
             extend = -0.5, 
             label ='SX') 
```


## Creation of sequence logos and alignment printing

For the creation of the R2 domain sequence logos the position of the R2 domain has to be manually specified in the alignment. The process cannot be automised therefore I did not include it in the pipeline. I provided the code used for the creation of the sequence logos.


### Sequence logo

All necessary additional packages are loaded.
\
```{r}
library(msa)
library(ggseqlogo)
```

The alignment, created with the CLUSTALW application and manually edited with the seaview software, can be imported into R using the Biostrings package. To mask all other parts of the alignment, except for the MYB domain, the IRanges objects defining the mask before (mask_start) and after (mask_end) the domain has to be manually defined for each alignment.
\
```{r, eval=FALSE}
# Read edited alignment
alignment <- readAAMultipleAlignment(filepath = 'Output/CLUSTALW/combined_filtered.aln', 
                                     format = 'clustal')

## Mask a part of the alignment
### A part of the alignment can be masked if only a part should be printed
### A masked alignment is also used to create the sequence logo
### Modify the IRanges objects that define the masked part at the 
### start and the end of the alignment
alignment_mask <- alignment
mask_end <- IRanges(start=256,end=1191)
mask_start <- IRanges(start=1,end=201)
colmask(alignment_mask) <- mask_end
colmask(alignment_mask) <- mask_start
```

For the creation of the sequence logo, the masked alignment is converted to a consensus matrix. Masked parts of the alignment appear in the matrix as NA and are removed before the creation of the sequence logo. The ggseqlogo package is used to create the sequence logo. The ggplot syntax is used for the creation of the logos. 
\
```{r, eval=FALSE}
# Create the sequence logo
## Convert the alignment to a consensus matrix
### Masked columns will appear as 'NA' in the matrix, 
### for the logo to appear correctly all column containing only NA are removed
alignment_matrix <- consensusMatrix(alignment_mask)
alignment_matrix <- alignment_matrix[ , !apply(is.na(alignment_matrix), 2, all)]
## The weblogo is printed using the ggseqlogo() function, the ggplot syntax can be used
weblogo <- ggplot() +
  geom_logo(data=alignment_matrix, 
            col_scheme='chemistry', 
            font='helvetica_regular', 
            stack_width = 0.95) +
  xlab('Position in domain') +
  theme_logo(base_size = 13) +
  theme(axis.text.y = element_text(size=20),
        axis.title.y = element_text(size=20),
        axis.title.x = element_text(size=20),
        legend.title = element_text(size=20),
        legend.text = element_text(size=20))

weblogo
ggsave(filename = paste("Plots/",params$myParam1,"_weblogo.pdf"))
```

### Alignment printing

Pictures of alignments were created using the msaPrettyPrint function from the msa package. The function prints the alignment to a pdf file. In case not the entire alignment shall be printed, parts of the alignment can be masked using the same code as in the "Sequence logo" section.  
\
```{r, eval=FALSE}
## The msaPrettyPrint function can be used to print the alignment to a pdf
msaPrettyPrint(alignment, 
               output='pdf',
               showNames='left', 
               showNumbering='right', 
               showConsensus ='bottom',
               consensusColors='ColdHot',
               shadingMode='similar', 
               showLogo='none', 
               askForOverwrite=F, 
               verbose=T,
               furtherCode=c("\\showruler{1}{top}"),
               file = paste("Data/",params$myParam1,"_alignment.pdf"))
```





